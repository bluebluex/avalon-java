### 对象头
HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。

HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于**存储对象自身的运行数据**，如**哈希吗(HahsCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等**，这部分数据的长度在32位和64位的虚拟机(暂时不考虑开启压缩指针的场景)中分别为32个和64个Bits，官方称它为"Mark Word"。

对象需要存储的运行数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，他会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希吗，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bits固定为0，在其他状态(轻量级锁定、重量级锁定、GC标记、可偏向)下对象的存储内容可以变(图片 H_001)。

对象头的另外一部分是**类型指针**，即是对象指向它的**类的元数据的指针**，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换季话说查找对象元数据信息并不一定经过对象本身。另外，如果对象是一个Java数据，在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以用过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。

这里特别股关注的是**锁标志位**，锁标志位与是否偏向锁对应到唯一的锁状态。
**锁的状态保存在对象头中，Synchronized锁的是对象，而不是锁代码**

---

### 锁的状态
锁总共有四种：**无锁状态、偏向锁、轻量级锁和重量级锁**。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁(但是锁的升级是单向的，也就是说只能从低级到高级，不会出现锁的降级 *！？*)。JDK1.6中默认是开启偏向锁和轻量级锁的，可以通过：-XX:-UseBiasedLocking  来禁用偏向锁。

---
- 轻量级锁的加锁过程
1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态(锁标志为"01"状态，是否为偏向锁为"0")，虚拟机首先将**当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间**，用于存储对象目前的Mark Word的拷贝，官方称之为"Displaced Mark Word"。这时候线程堆栈与对象头的状态(图片 H_002)；
2. 拷贝对象头中的Mark Word复制到锁记录中
3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的Owner指针指向Object Mark Word。如果更新成功，则执行步骤4，否则执行步骤5。
4. 如果这个CAS更新操作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为"00"，即表示此对象处于轻量级锁定状态,这时候线程堆栈与对象头的状态(图片 H_003);
5. 如果这个CAS更新操作失败，虚拟机首先会检查对象的Mark WOrd是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步代码块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态变为"10"，Mark WOrd中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。